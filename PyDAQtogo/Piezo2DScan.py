#%%
"""
Created on Tue May  4 11:03:02 2021
@author: Zhu Zhang <z.zhang@uu.nl>

code to scan the PI nanocube Piezo in a snake shape in x and y direction, to get the point
spread function by the signal of FEMTO Photo Diode. In this way we can check
the point spread function of the pinhole which is put at the front of the PD.
The PI control signal is generated by the NI DAQ card.
 
"""
import numpy as np
from PyDAQmx import *
from ctypes import byref
from scipy import signal
import time
import matplotlib.pyplot as plt
import os
from mpl_toolkits.axes_grid1 import make_axes_locatable
import ProgressBar as PB

import HPWaveGen
import PyDAQtogo.NIDAQforPDSM as daq

import PyDAQtogo.SRSLockinAmplifier as SRS
import PyDAQtogo.config as config

configfile = config.find_configfile("config_Zhu.yml")
param = config.read_config(configfile)   
"""
Linear scan in x direction and step scan in y direction
The movement range of the piezo in x,y direction is 100um, which will be controlled
by a external voltage with range of 10V. So movement to the control voltage is 100/10 um/V
That is 10um/V
"""
#==============================================================================
#Define the function to generate snake scan route
#==============================================================================
class PiezoXYScan(Task):
    def __init__(self, x_start, x_stop, x_steps, y_start, y_stop, y_steps, scanRate, freq, amp):
        Task.__init__(self)
        self.dpv = 10 # distance per Voltage 10um/V
        if amp != 0:
            self.sampleRate = 100.0*freq # DAQ output rate
        else:
            self.sampleRate = 5000.0
        self.scanRate = scanRate # um/s
        self.freq = freq
        read = int32()
        self.x_start = x_start; self.x_stop = x_stop; 
        self.x_steps = int(self.sampleRate*abs(self.x_stop-self.x_start)/self.scanRate)
        self.y_start = y_start; self.y_stop = y_stop; 
        self.y_steps = int(y_steps)
#        self.x = signal.sawtooth(2 * np.pi * 5 * t, 0.5)
        self.x = np.linspace(start = self.x_start/self.dpv, stop = self.x_stop/self.dpv, num = self.x_steps+1)
        self.y = np.linspace(start = self.y_start/self.dpv, stop = self.y_stop/self.dpv, num = self.y_steps+1)
        self.singleScan = np.append(self.x, self.x[::-1])
        self.xStepArray = np.array(())
        self.xStepArray = np.tile(self.singleScan, len(self.y))
        self.yStepArray = np.repeat(self.y, int(len(self.singleScan)))
        
#        for i in range(len(self.y)):
#            if i%2 ==0:
#                self.xStepArray = np.append(self.xStepArray,self.x)
#            else:
#                self.xStepArray = np.append(self.xStepArray,self.x[::-1])
#        self.yStepArray = np.repeat(self.y, int(len(self.x)))
        
        self.xStepArray =np.append(self.xStepArray, np.ones(int(self.sampleRate))*self.x_start/self.dpv)
        self.yStepArray =np.append(self.yStepArray, np.ones(int(self.sampleRate))*self.y_stop/self.dpv)
        self.t = np.linspace(start = 0, stop =1, num = len(self.xStepArray), endpoint = False)
        
#        self.t = np.linspace(0, 1, int(self.sampleRate*period), endpoint=False)
              
        self.time = len(self.xStepArray)/self.sampleRate
        self.sin = np.sin(2*np.pi*self.freq*self.time*self.t)*amp*1e-3
        
        """the signal which will be sent to AO0 and AO1 are stacked because I choose the the fillmode of 'DAQmx_Val_GroupByChannel'
        in the WriteAnalogF64 function, which means the data is grouped by channel(non-interleaved), check the Interleaving on 
        https://zone.ni.com/reference/en-XX/help/370466AH-01/mxcncpts/interleaving/ for more details"""
        self.signal2DAQScan = np.append(self.xStepArray+self.sin, self.yStepArray)
        self.Ch1outLim = max(abs(self.x_stop), abs(self.x_start))/self.dpv*2
        self.Ch2outLim = max(abs(self.y_stop), abs(self.y_start))/self.dpv*2
        self.CreateAOVoltageChan("Dev2/ao0", "", -self.Ch1outLim, self.Ch1outLim, DAQmx_Val_Volts, None)
        self.CreateAOVoltageChan("Dev2/ao1", "", -self.Ch2outLim, self.Ch2outLim, DAQmx_Val_Volts, None)
        self.CfgSampClkTiming("", int(self.sampleRate), DAQmx_Val_Rising, DAQmx_Val_ContSamps, int(self.sampleRate))
        # self.sampleRate ----The sampling rate in samples per second per channel
        #self.Num ----The number of samples to acquire or generate for each channel in the task( in every period)   self.num*signal_frq=self.N
        self.WriteAnalogF64(int(self.sampleRate*self.time),bool32(False),-1, DAQmx_Val_GroupByChannel,self.signal2DAQScan,byref(read),None)
        # self.sampleRate*self.time ---The number of samples, per channel, to write
        print("The Pizeo is scanning now.....\nThe whole scan will take %f s, about %.1f minutes.\n"%(self.time, self.time/60.0))

#==============================================================================
#Define the function to move the piezo to the starting corner
#==============================================================================

class PiezoGotoStartCorner(Task):
    def __init__(self, x_start, y_start, moveSpeed):
        Task.__init__(self)
        self.dpv = 10.0
        self.sampleRate = 2000.0
        if abs(x_start) != abs(y_start):
            self.moveSpeedx = moveSpeed * abs(x_start)/abs(y_start)
            self.moveSpeedy = moveSpeed
        else:
            self.moveSpeedx = moveSpeed; self.moveSpeedy = moveSpeed
                
        read = int32()
        self.x_start = x_start; self.y_start = y_start
        self.x_steps = int(self.sampleRate*abs(self.x_start)/self.moveSpeedx)
        self.y_steps = int(self.sampleRate*abs(self.y_start)/self.moveSpeedy)
        
        self.x = np.linspace(start = 0, stop = self.x_start/self.dpv, num = self.x_steps+1)
        self.y = np.linspace(start = 0, stop = self.y_start/self.dpv, num = self.y_steps+1)
        self.x =np.append(self.x, np.ones(int(self.sampleRate))*self.x_start/self.dpv)
        self.y =np.append(self.y, np.ones(int(self.sampleRate))*self.y_start/self.dpv)
        self.time = len(self.x)/self.sampleRate
        self.signal2DAQ2Corner = np.append(self.x, self.y)
        self.Ch1outLim = max(0, abs(self.x_start/self.dpv))*4
        self.Ch2outLim = max(0, abs(self.y_start/self.dpv))*4
        self.CreateAOVoltageChan("Dev2/ao0", "", -self.Ch1outLim, self.Ch1outLim, DAQmx_Val_Volts, None)
        self.CreateAOVoltageChan("Dev2/ao1", "", -self.Ch2outLim, self.Ch2outLim, DAQmx_Val_Volts, None)
        self.CfgSampClkTiming("", int(self.sampleRate), DAQmx_Val_Rising, DAQmx_Val_ContSamps, int(self.sampleRate))
        # self.sampleRate ----The sampling rate in samples per second per channel
        #self.Num ----The number of samples to acquire or generate for each channel in the task( in every period)   self.num*signal_frq=self.N
        self.WriteAnalogF64(int(self.sampleRate*self.time),bool32(False),-1, DAQmx_Val_GroupByChannel,self.signal2DAQ2Corner,byref(read),None)
        # self.sampleRate*self.time ---The number of samples, per channel, to write
        print("Bringing the Piezo to the start corner.....\nWill take %f s, about %.1f minutes.\n"%(self.time, self.time/60.0))

#==============================================================================
#Define the function to move the piezo to the cneter when the scan is done
#==============================================================================
class PiezoBacktoCenter(Task):
    def __init__(self, x_stop, y_stop, backSpeed):
        Task.__init__(self)
        self.dpv = 10.0
        self.sampleRate = 2000.0
        self.backSpeed = backSpeed
        
        if abs(x_stop) != abs(y_stop):
            self.backSpeedx = backSpeed * abs(x_stop)/abs(y_stop)
            self.backSpeedy = backSpeed
        else:
            self.backSpeedx = backSpeed; self.backSpeedy = moveSpeed
            
        read = int32()
        self.x_stop = x_stop; self.y_stop = y_stop
        self.x_steps = int(self.sampleRate*abs(self.x_stop)/self.backSpeedx)
        self.y_steps = int(self.sampleRate*abs(self.y_stop)/self.backSpeedy)
        
        self.x = np.linspace(start = self.x_stop/self.dpv, stop = 0, num = self.x_steps+1)
        self.y = np.linspace(start = self.y_stop/self.dpv, stop = 0, num = self.y_steps+1)
        self.x =np.append(self.x, np.ones(int(self.sampleRate))*0/self.dpv)
        self.y =np.append(self.y, np.ones(int(self.sampleRate))*0/self.dpv)
        
        self.time = max(len(self.x),len(self.y))/self.sampleRate
        self.signal2DAQBC = np.append(self.x, self.y)
        self.Ch1outLim = max(0, abs(self.x_stop))
        self.Ch2outLim = max(0, abs(self.y_stop))
        self.CreateAOVoltageChan("Dev2/ao0", "", -self.Ch1outLim, self.Ch1outLim, DAQmx_Val_Volts, None)
        self.CreateAOVoltageChan("Dev2/ao1", "", -self.Ch2outLim, self.Ch2outLim, DAQmx_Val_Volts, None)
        self.CfgSampClkTiming("", int(self.sampleRate), DAQmx_Val_Rising, DAQmx_Val_ContSamps, int(self.sampleRate))
        # self.sampleRate ----The sampling rate in samples per second per channel
        #self.Num ----The number of samples to acquire or generate for each channel in the task( in every period)   self.num*signal_frq=self.N
        self.WriteAnalogF64(int(self.sampleRate*self.time),bool32(False),-1, DAQmx_Val_GroupByChannel,self.signal2DAQBC,byref(read),None)
        # self.sampleRate*self.time ---The number of samples, per channel, to write
        print("Bringing the Piezo back to the center.....\nWill take %f s, about %.1f minutes.\n"%(self.time, self.time/60.0))        

#==============================================================================
# Define the function of acquirement to get data from analog input  channel
#==============================================================================
class MeasureTask(Task):
    def __init__(self):
        Task.__init__(self)
        # Create data storages:
        self.samplerate = 1000.0
        self.updatadataevery = 10
        self.inputchannelsN = 5
        self.data = np.zeros(self.inputchannelsN*self.updatadataevery)
        self.a = []
        self.CreateAIVoltageChan("Dev1/ai0","Voltage_x",DAQmx_Val_Diff,-10.0,10.0,DAQmx_Val_Volts,None)# from AI0
        self.CreateAIVoltageChan("Dev1/ai1","Voltage_y",DAQmx_Val_Diff,-10.0,10.0,DAQmx_Val_Volts,None)# from AI1
        self.CreateAIVoltageChan("Dev1/ai3","LockinX",DAQmx_Val_Diff,-10.0,10.0,DAQmx_Val_Volts,None) #from lockin output x
        self.CreateAIVoltageChan("Dev1/ai4","PD",DAQmx_Val_Diff,-10.0,10.0,DAQmx_Val_Volts,None) #from femto PD
        self.CreateAIVoltageChan("Dev1/ai5","LockinY",DAQmx_Val_Diff,-10.0,10.0,DAQmx_Val_Volts,None) #from lockin output y
        # refer to http://zone.ni.com/reference/en-XX/help/370471AA-01/daqmxcfunc/daqmxcreateaivoltagechan/
        # refer to http://zone.ni.com/reference/en-XX/help/370471AA-01/daqmxcfunc/daqmxcreateaivoltagechan/
        self.CfgSampClkTiming("",self.samplerate,DAQmx_Val_Rising,DAQmx_Val_ContSamps,1000) # 1000.0 is the sampling rate
        # refer to http://zone.ni.com/reference/en-XX/help/370471AA-01/daqmxcfunc/daqmxcfgsampclktiming/
                 
        self.AutoRegisterEveryNSamplesEvent(DAQmx_Val_Acquired_Into_Buffer, self.updatadataevery, 0)
        # refer to http://zone.ni.com/reference/en-XX/help/370471AM-01/daqmxcfunc/daqmxregistereverynsamplesevent/
        self.AutoRegisterDoneEvent(0)
    def EveryNCallback(self):
        read = int32()
        # Handle data, done every "updatadataevery" measurements
        self.ReadAnalogF64(self.updatadataevery, 10.0, DAQmx_Val_GroupByScanNumber, self.data, self.inputchannelsN*self.updatadataevery, byref(read), None)
        self.a.extend(self.data.tolist())
        return 0 # The function should return an integer
    def DoneCallback(self, status):
        print("Status",status.value)
        return 0 # The function should return an integer

#==============================================================================
# Define the function to zero the optput channels atfer the measurement is done
#==============================================================================
class ZeroOutput(Task):
    def __init__(self):
        Task.__init__(self)
        self.CreateAOVoltageChan("Dev2/ao0","",-1.0,1.0,DAQmx_Val_Volts,None)
        self.CreateAOVoltageChan("Dev2/ao1","",-1.0,1.0,DAQmx_Val_Volts,None)
        self.CfgSampClkTiming("", int(10), DAQmx_Val_Rising, DAQmx_Val_ContSamps, int(10))
        self.WriteAnalogF64(int(10),bool32(False),-1,DAQmx_Val_GroupByChannel,np.zeros((1,20)),byref(int32()),None)

#%%
#movieN=15

v_min = -50
v_max = 50
try:
    lockinA = SRS.SR830(COMPort='ASRL8::INSTR', timeout=5000)
except:
    print("The SR830 is alreday opended!")
lockinA.CLS()   

lockinA.time_constant(Tc = "300 ms")
lockinA.sensitivity(sen = '5 mV/nA')
#m_freqs = [10, 25, 50, 75, 100, 150, 200, 300, 500, 750, 1000]
# m_freqs = [ 10, 25, 45, 75, 95, 160, 210, 300, 400, 500,750, 1000]
m_freqs = [  200]
# m_freqs = [95]
# m_ampls = [105, 95, 85, 75, 65, 55 , 45, 35, 25 , 15][::-1]
#m_ampls = [105, 85,  65, 45, 25 , 15]
m_ampl = 75
Extra_amp = 0 
# scanrates = [100, 90, 80, 70, 60, 50, 40, 30, 25, 20 , 15, 10][::-1]
# scanrates = [100, 90, 80, 70, 60, 50, 40, 30, 20 , 10][::-1]
scanrates = [200]
scanrate = 50
# of = 150
# ofs = np.arange(-200,250, 60)
ofs = [  75, -250,  0, 125,   -100, -50, 300]
ofs = [  75]

saveloc = 'C:\\Data\\Bakis\\20230126'
savename = "test1"

try:
    del movieN
except:
    pass

for m_freq in m_freqs:
    for of in ofs:
        
        try:
            taskMod.StopTask()
            taskMod.ClearTask()
            time.sleep(1)
        except:
            pass
        
        """CV : choose 0 or 1, 0 just do sine oscillation, 1 do AC voltammetry`
           reverse: 1 or -1, 1 not reverse when use dualPicostat, 1 reverse for Picostat with range of larger current input 
           have tested the pico, the voltage output to cell is correct, the output to daq is reserved """
        taskMod = daq.StepSinGenerator(step =2*1e-3,m_freq=m_freq,m_ampl=m_ampl+ Extra_amp,v_min= v_min,v_max=v_max,v_scanRate=scanrate, CV=0,offset=of,reverse=1)
        
        taskMod.StartTask()
        
        
    
        
        freq = 0.1; amp= 0;  # this line doesn't need to change, it is for piezo modulation
        x_start = -7; x_stop = 7
        y_start = -7; y_stop = 7
        x_steps = 20; y_steps = 30 # Y_steps shoud be even number
        moveSpeed =0.5
        moveTime = max(abs(x_start),abs(y_start))/moveSpeed
        scanRate = 2
        scanTime = int(y_steps)*(abs(x_stop)+abs(x_start))/scanRate
        backSpeed = 0.5
        backTime = max(abs(x_stop),abs(y_stop))/backSpeed
        
        
        
        task2Corner = PiezoGotoStartCorner(x_start, y_start, moveSpeed)
        movieTime = len(task2Corner.x)/task2Corner.sampleRate-0.5
        task2Corner.StartTask()
        # time.sleep(movieTime)
        PB.ShowBar(Barname = "MoveProgress", runtime = movieTime)
            
        task2Corner.StopTask()
        task2Corner.ClearTask()
        print("Alread reached the corner point, ready to scan.")
        
        taskScan = PiezoXYScan(x_start, x_stop, x_steps, y_start, y_stop, y_steps, scanRate, freq, amp)
        scanTime = len(taskScan.xStepArray)/taskScan.sampleRate-0.5
        taskMeas = MeasureTask()
        taskScan.StartTask()
        taskMeas.StartTask()
        # time.sleep(scanTime)
        PB.ShowBar(Barname = "ScanProgress", runtime = scanTime)
        
        taskScan.StopTask()
        taskMeas.StopTask()
        taskScan.ClearTask()
        taskMeas.ClearTask()
        print("The scan is done, ready back to center.")
        
        taskBack = PiezoBacktoCenter(x_start, y_stop, backSpeed)
        taskBack.StartTask()
        # time.sleep(backTime)
        PB.ShowBar(Barname = "BackProgress", runtime = backTime)
        taskBack.StopTask()
        taskBack.ClearTask()
        print("back to center is done.")
        
        
        # taskZero = ZeroOutput()
        # taskZero.StartTask()
        # taskZero.StopTask()
        # taskZero.ClearTask()
        
        
        taskMod.StopTask()
        taskMod.ClearTask()
        # taskZ = daq.ZeroOutput()
        # taskZ.StartTask()
        # taskZ.StopTask()
        # taskZ.ClearTask()
        
       
        
        
        if not os.path.exists(saveloc):
            os.mkdir(saveloc)
            print("Directory " , saveloc ,  " Created ")
        else:    
            print("Directory " , saveloc ,  " already exists")
        
        
        #sn = savename
        try:
            movieN += 1
            
        except:
            movieN = 0
            sn = savename
            
        savefileandpath = (saveloc+"\\"+savename+"_m"+str(movieN))
        # Get and save measured data:
        mdata = np.array(taskMeas.a).reshape(-1,taskMeas.inputchannelsN)
        
        ## STEP 5: save the log file and the config file in the same directory as data
        np.save(savefileandpath, mdata)
        
        
         
        
        pi = np.pi
        sr =1000
        DAC = np.load(saveloc+"\\"+savename+"_m"+str(movieN)+'.npy')
        #x_start =-2.5; x_stop=2.5 ; scanRate=1 
        #DAC = np.load(saveloc+"\\"+savename+"_m"+str(3)+'.npy')
        lockin = DAC[:len(DAC)-int(len(DAC)%int((x_stop-x_start)/scanRate*sr)),3]
        lockinArr= np.array(lockin).reshape(-1, int((x_stop-x_start)/scanRate*sr))
        
        for i in range(lockinArr.shape[0]):
            if i%2 ==0:
                lockinArr[i,:] = lockinArr[i,::-1]
        #    print(i)
        
        lockinArrF = lockinArr[::2,:]
        lockinArrB = lockinArr[1::2,:]
        %matplotlib inline
        fig, ax = plt.subplots(figsize=(10,10))
        #%matplotlib qt
        #%matplotlib inline
        im = ax.imshow(np.flip(np.flip(lockinArrF.T,0),1), cmap = 'afmhot', aspect='auto', vmin=0.0,vmax=None)
        divider = make_axes_locatable(ax)
        cax = divider.append_axes("right", size="5%", pad=0.05)
        
        plt.colorbar(im, cax=cax)
        fig.savefig(fname = saveloc+"\\"+savename+"_m"+str(movieN) + "_PD"+ ".png", dpi=600, format='png') 
        plt.show()
        
        v = DAC[:len(DAC)-int(len(DAC)%int((x_stop-x_start)/scanRate*sr)),0]
        c = DAC[:len(DAC)-int(len(DAC)%int((x_stop-x_start)/scanRate*sr)),1]
        lockinx = DAC[:len(DAC)-int(len(DAC)%int((x_stop-x_start)/scanRate*sr)),2]
        lockiny = DAC[:len(DAC)-int(len(DAC)%int((x_stop-x_start)/scanRate*sr)),4]
        lockinR =np.sqrt(lockinx*lockinx+lockiny*lockiny)
        # lockinR = lockiny
        lockinp = np.arctan2(lockiny,lockinx)*180/np.pi
        lockinRArr= np.array(lockinR).reshape(-1, int((x_stop-x_start)/scanRate*sr))
        lockinYArr= np.array(lockiny).reshape(-1, int((x_stop-x_start)/scanRate*sr))
        lockinXArr= np.array(lockinx).reshape(-1, int((x_stop-x_start)/scanRate*sr))
        for i in range(lockinRArr.shape[0]):
            if i%2 ==0:
                lockinRArr[i,:] = lockinRArr[i,::-1]
                lockinXArr[i,:] = lockinXArr[i,::-1]
                lockinYArr[i,:] = lockinYArr[i,::-1]
        #    print(i)
        
        lockinRArrF = lockinRArr[::2,:]
        lockinRArrB = lockinRArr[1::2,:]
        #%matplotlib inlinez
        fig, ax = plt.subplots(figsize=(10,10))
        #%matplotlib qt
        im= ax.imshow(np.flip(np.flip(lockinRArrF.T,0),1), cmap = 'Spectral_r', aspect='auto', vmin=0.0,vmax= None)
        divider = make_axes_locatable(ax)
        cax = divider.append_axes("right", size="5%", pad=0.05)
        
        plt.colorbar(im, cax=cax)
        fig.savefig(fname = saveloc+"\\"+savename+"_m"+str(movieN) + "_R"+ ".png", dpi=600, format='png') 
        #plt.ylim(-0.5, 1.5)
        plt.show()
        
        lockinYArrF = lockinYArr[::2,:]
        lockinYArrB = lockinYArr[1::2,:]
        #%matplotlib inlinez
        fig, ax = plt.subplots(figsize=(10,10))
        #%matplotlib qt
        im= ax.imshow(np.flip(np.flip(lockinYArrF.T,0),1), cmap = 'Spectral_r', aspect='auto', vmin=0.0,vmax= None)
        divider = make_axes_locatable(ax)
        cax = divider.append_axes("right", size="5%", pad=0.05)
        
        plt.colorbar(im, cax=cax)
        fig.savefig(fname = saveloc+"\\"+savename+"_m"+str(movieN) + "_y"+ ".png", dpi=600, format='png') 
        #plt.ylim(-0.5, 1.5)
        plt.show()
        
        
        lockinpArr= np.array(lockinp).reshape(-1, int((x_stop-x_start)/scanRate*sr))
        for i in range(lockinpArr.shape[0]):
            if i%2 ==0:
                lockinpArr[i,:] = lockinpArr[i,::-1]
        #    print(i)
        
        lockinpArrF = lockinpArr[::2,:]
        lockinpArrB = lockinpArr[1::2,:]
        #%matplotlib inlinez
        fig, ax = plt.subplots(figsize=(10,10))
        #%matplotlib qt
        
        #%matplotlib qt
        im =ax.imshow(np.flip(np.flip(lockinpArrF.T,0),1), cmap = 'Spectral_r', aspect='auto', vmin=0.0,vmax= None)
        divider = make_axes_locatable(ax)
        cax = divider.append_axes("right", size="5%", pad=0.05)
        
        plt.colorbar(im, cax=cax)
        #plt.ylim(-0.5, 1.5)
        fig.savefig(fname = saveloc+"\\"+savename+"_m"+str(movieN) + "_lockinp"+ ".png", dpi=600, format='png')
        plt.show()
        
        
        param['Lock-in']['input_config']=lockinA.query_input_config()  ## this is an example of reading from a dictionary, fill in the rest as necessary
        param['Lock-in']['input_coupling']=lockinA.query_input_coupling()
        param['Lock-in']['input_shield']=lockinA.query_input_shield()
        param['Lock-in']['input_filter']=lockinA.query_input_filter()
        
        param['Lock-in']['time_constant']=lockinA.query_time_constant()
        param['Lock-in']['sensitivity']=lockinA.query_sensitivity()
        param['Lock-in']['filter_slope']=lockinA.query_filter_slope()
        param['Lock-in']['reserve_mode']=lockinA.query_reserve_mode()
        param['Lock-in']['sync_filter']=lockinA.query_sync_filter()
        
        param['Lock-in']['frequency']=lockinA.query_frequency()
        param['Lock-in']['reference_source']=lockinA.query_reference_source()
        param['Lock-in']['reference_trigger']=lockinA.query_reference_trigger()
        param['Lock-in']['harm']=lockinA.query_harm()
        
        param['Scan']['xStart']= x_start
        param['Scan']['xEnd']= x_stop
        param['Scan']['yStart']= y_start
        param['Scan']['yEnd']= y_stop
        param['Scan']['ySteps']= y_steps
        param['Scan']['SR']= scanRate
        
        param['Measurement']['v_offset'] = int(of)
        param['Measurement']['a_modulate'] = m_ampl
        param['Measurement']['f_modulate'] = m_freq
        param['Measurement']['v_max'] = v_max
        param['Measurement']['v_min'] = v_min
        config.save_config( param,saveloc+"\\"+savename+"_m"+str(movieN))
taskI = daq.InitialOutput()
taskI.StartTask()
taskI.StopTask()
taskI.ClearTask()


#%%
import numpy as np
from scipy import optimize
##https://scipy-cookbook.readthedocs.io/items/FittingData.html
# https://lmfit.github.io/lmfit-py/examples/example_two_dimensional_peak.html

def gaussian(height, center_x, center_y, width_x, width_y):
    """Returns a gaussian function with the given parameters"""
    width_x = float(width_x)
    width_y = float(width_y)
    return lambda x,y: height*np.exp(
                -(((center_x-x)/width_x)**2+((center_y-y)/width_y)**2)/2)

def moments(data):
    """Returns (height, x, y, width_x, width_y)
    the gaussian parameters of a 2D distribution by calculating its
    moments """
    total = data.sum()
    X, Y = np.indices(data.shape)
    x = (X*data).sum()/total
    y = (Y*data).sum()/total
    col = data[:, int(y)]
    width_x = np.sqrt(np.abs((np.arange(col.size)-x)**2*col).sum()/col.sum())
    row = data[int(x), :]
    width_y = np.sqrt(np.abs((np.arange(row.size)-y)**2*row).sum()/row.sum())
    height = data.max()
    return height, x, y, width_x, width_y

def fitgaussian(data):
    """Returns (height, x, y, width_x, width_y)
    the gaussian parameters of a 2D distribution found by a fit"""
    params = moments(data)
    errorfunction = lambda p: np.ravel(gaussian(*p)(*np.indices(data.shape)) -
                                 data)
    p, success = optimize.leastsq(errorfunction, params)
    return p

# Create the gaussian data
Xin, Yin = np.mgrid[0:201, 0:201]
data = gaussian(3, 100, 100, 20, 40)(Xin, Yin) + np.random.random(Xin.shape)
test = np.flip(np.flip(lockinArrF.T,0),1)
plt.figure(figsize=(10,10))
plt.imshow(test, cmap=plt.cm.gist_earth_r, aspect='auto')
data =test
params = fitgaussian(data)
fit = gaussian(*params)

plt.contour(fit(*np.indices(data.shape)), cmap=plt.cm.copper, aspect='auto')
ax = plt.gca()
(height, x, y, width_x, width_y) = params

plt.text(0.95, 0.05, """
x : %.1f
y : %.1f
width_x : %.1f
width_y : %.1f""" %(x, y, width_x, width_y),
        fontsize=16, horizontalalignment='right',
        verticalalignment='bottom', transform=ax.transAxes)






from matplotlib import cm
from matplotlib.ticker import LinearLocator
import numpy as np

fig, ax = plt.subplots(subplot_kw={"projection": "3d"})

# Make data.
X = np.arange(-5, 5, 10/data.shape[1])
Y = np.arange(-5, 5, 10/data.shape[0])
X, Y = np.meshgrid(X, Y)
R = np.sqrt(X**2 + Y**2)
Z = np.sin(R)

# Plot the surface.
surf = ax.plot_surface(X, Y, data, cmap=plt.cm.gist_earth_r,
                        linewidth=0, antialiased=False)

# Customize the z axis.
ax.set_zlim(-1.01, None)
ax.zaxis.set_major_locator(LinearLocator(10))
# A StrMethodFormatter is used automatically
ax.zaxis.set_major_formatter('{x:.02f}')

# Add a color bar which maps values to colors.
fig.colorbar(surf, shrink=0.5, aspect=10)


fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
X = np.arange(-5, 5, 10/data.shape[1]/5)
Y = np.arange(-5, 5, 10/data.shape[0]*5)
X, Y = np.meshgrid(X, Y)
params[2] *= 5; params[4] *= 5
params[1] /= 5; params[3] /= 5
gaussian(*params)
fit_new = gaussian(*params)
fitting = fit_new(*np.indices((X.shape)))
surf = ax.plot_surface(X, Y, fitting, cmap=plt.cm.gist_earth_r,
                        linewidth=0, antialiased=False)

# Customize the z axis.
ax.set_zlim(-1.01, None)
ax.zaxis.set_major_locator(LinearLocator(10))
# A StrMethodFormatter is used automatically
ax.zaxis.set_major_formatter('{x:.02f}')

# Add a color bar which maps values to colors.
fig.colorbar(surf, shrink=0.5, aspect=10)

plt.show()


# fig, ax = plt.subplots(figsize=(30,10))
# t = (np.linspace(0,len(lockin),len(lockin)))/sr
# ax.plot(t,  lockin, '-',  color = 'b',label= "PD" )
# ax2 = ax.twinx()
# ax2.plot(t, lockinR ,'-', color = 'r',label= "Lockin" )
# #ax.set_yscale('log')
# #ax.legend(fontsize=15)
# ax.tick_params(axis='x', labelcolor='k', labelsize=25, pad =10)
# ax.tick_params(axis='y', labelcolor='b', labelsize=25, pad =10)
# ax2.tick_params(axis='y', labelcolor='r', labelsize=25, pad =10)
# ax.set_xlabel('Time [s]',fontsize=25)
# ax.set_ylabel('PD Voltage',fontsize=25, color = 'b')
# ax2.set_ylabel('Lockin Voltage',fontsize=25, color = 'r' )
# plt.tight_layout()
# from math import pi
# fig, ax = plt.subplots(figsize=(30,10))
# t = (np.linspace(0,len(lockin),len(lockin)))/sr
# ax.plot(t,  lockinx, '-',  color = 'b',label= "lockin" )
# ax.plot(t,  lockiny, '-',  color = 'r',label= "lockin" )
# ax.plot(t,  lockinR, '-',  color = 'c',label= "lockin" )
# ax.tick_params(axis='y', labelcolor='r', labelsize=25, pad =10)
# ax2 = ax.twinx()
# ax2.plot(t,  lockinp*180/pi, '-',  color = 'k',label= "lockin" )
# ax2.tick_params(axis='y', labelcolor='k', labelsize=25, pad =10)


# fig, ax = plt.subplots(figsize=(30,10))
# t = (np.linspace(0,len(lockin),len(lockin)))/sr
# ax.plot(t,  v, '-',  color = 'b',label= "lockin" )
# ax.plot(t,  c, '-',  color = 'r',label= "lockin" )

# ax.tick_params(axis='y', labelcolor='r', labelsize=25, pad =10)


# ax2 = ax.twinx()
# ax2.plot(t,  c/10*180, '-',  color = 'k',label= "lockin" )
# ax2.tick_params(axis='y', labelcolor='k', labelsize=25, pad =10)
#%%
savefileandpath = (saveloc+"\\")
labJournalname = savefileandpath + "2021-05-27_GNP" +".txt"
#f= open(labJournalname+ "labJournaltest"+".txt","w+")

if not os.path.isfile(labJournalname):
    f= open(labJournalname,"w+")
    print("Lab Journal", labJournalname, "Created")
else:
    f= open(labJournalname,"a")
    print("Lab Journal", labJournalname, "Will be updated")

f.write(savename +'_' + str(movieN) + "\t" + "x\t" + "a\n"  )
f.close()    


#%%

#x_start =-2.5; x_stop=2.5 ; scanRate= 0.75
DAC = np.load(saveloc+"\\"+savename+"_m"+str(movieN)+'.npy')
lockin = DAC[:len(DAC)-int(len(DAC)%int((x_stop-x_start)/scanRate*2000)),3]
DAC_pd = lockin
N = len(DAC_pd)
import numpy.fft as fft   
    # Sampling rates
SR = 10000
T = 1/SR
    #x = np.linspace(0.0, N*T, N)
x = np.linspace(0, N, num = N)
y = DAC_pd-np.mean(DAC_pd)*0
#driftcorrected_pd = \
#        dfsm.correct_particle_drift(y, polyorfft='fft', polyorder=8, fftfilter=100)
#yf = rfft(y)
#yf_driftcorrected = rfft(driftcorrected_pd)
#xf = rfftfreq(N, T)[:N//2]
# The FFT of the signal
sig_fft = fft.fft(y)
# And the power (sig_fft is of complex dtype)
power = np.abs(sig_fft)

# The corresponding frequencies
sample_freq = fft.fftfreq(y.shape[-1], T)
# Plot the FFT power
plt.figure(figsize=(12, 5))
plt.plot(sample_freq, power)
plt.tick_params(axis='x', labelcolor='k', direction="in", length=6, width=2,labelsize=30, pad =10)
plt.xlabel('Frequency [Hz]', fontsize = 25)
plt.ylabel('plower')
plt.axis([1, 400,0, 1000])
plt.show()

high_freq_fft = sig_fft.copy()
high_freq_fft[np.abs(sample_freq) > 45] = 0
#high_freq_fft[np.abs(sample_freq) < 201] = 0
filtered_sig = abs(fft.ifft(high_freq_fft))

lockinArr= np.array(filtered_sig).reshape(-1, int((x_stop-x_start)/scanRate*10000))
for i in range(lockinArr.shape[0]):
    if i%2 ==0:
        lockinArr[i,:] = lockinArr[i,::-1]
#    print(i)
%matplotlib inline
fig, ax = plt.subplots(figsize=(10,10))
#%matplotlib qt
im = ax.imshow(np.flip(np.flip(lockinArr.T,0),1), cmap = 'afmhot', aspect='auto', vmin=0.0,vmax= None)
divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.05)

plt.colorbar(im, cax=cax)
plt.show()


lockinx0 = DAC[:len(DAC)-int(len(DAC)%int((x_stop-x_start)/scanRate*10000)),2]
lockiny0 = DAC[:len(DAC)-int(len(DAC)%int((x_stop-x_start)/scanRate*10000)),4]
lockinx= np.array(lockinx0).reshape(-1, int((x_stop-x_start)/scanRate*10000))
lockiny= np.array(lockiny0).reshape(-1, int((x_stop-x_start)/scanRate*10000))
lockinR =np.sqrt(lockinx*lockinx+lockiny*lockiny)
lockinArr = lockinR
#lockinArr= np.array(lockinR).reshape(-1, int((x_stop-x_start)/scanRate*2000))
for i in range(lockinArr.shape[0]):
    if i%2 ==0:
        lockinArr[i,:] = lockinArr[i,::-1]
#    print(i)
#%matplotlib inlinez
plt.figure(figsize=(10,10))
#%matplotlib qt
plt.imshow(np.flip(np.flip(lockinArr.T,0),1), cmap = 'Spectral_r', aspect='auto', vmin=0.0,vmax= None)

#plt.ylim(-0.5, 1.5)
plt.show()

#%%
plt.figure(figsize=(10,10))
sampleRate =2000.0
x_start = -2.5; x_stop = 2.5; 
scanRate = 1
x_steps = int(sampleRate*abs(x_stop-x_start)/scanRate)
y_start = -2.5; y_stop = 2.5;  dpv =1
y_steps = 4
y_steps = int(y_steps)
#        self.x = signal.sawtooth(2 * np.pi * 5 * t, 0.5)
x = np.linspace(start = x_start/dpv, stop = x_stop/dpv, num = x_steps+1)
y = np.linspace(start = y_start/dpv, stop = y_stop/dpv, num = y_steps+1)
xStepArray = np.array(())
for i in range(len(y)):
    if i%2 ==0:
        xStepArray = np.append(xStepArray,x)
    else:
        xStepArray = np.append(xStepArray,x[::-1])
yStepArray = np.repeat(y, int(len(x)))

#xStepArray =np.append(xStepArray)
#yStepArray =np.append(yStepArray)
t = np.linspace(start = 0, stop =1, num = len(xStepArray), endpoint = False)

#        self.t = np.linspace(0, 1, int(self.sampleRate*period), endpoint=False)
      
time = len(xStepArray)/sampleRate
sin = np.sin(2*np.pi*5*time*t)*200*1e-3

plt.plot(xStepArray, yStepArray+sin)

